# ejercicios4

Aca estaran las respuestas a la preguntas de teoria.

Ejercicio 34
Un algoritmo una secuencia de instrucciones que se llevan a cabo para cumplir una tarea.

Ejercicio 37 
En este caso la complejidad temporal depende de t, que es el tiempo, por lo que seria una complejidad constante de O(1).

Ejercicio 38
En estos dos metodos la complejidad no va a depender del tama√±o de la entrada. Por lo tanto siempre tendra la misma cantidad de tiempo, siendo O(1).

Ejercicio 39
En estos metodos creados, se usan bucles por lo que la complejidad temporal sera constante ya que crecera dependiendo de la entrada que se le de.Por lo tanto, la complejidad temporal seria O(n).

Ejercicio 40
La complejidad temporal de este metodo tambien es O(n).Esto al depender de la cantidad de datos que demos por entrada.

Ejercicio 41
La complejidad temporal de este ejercicio seria tambien de O(n), en algunos casos la complejidad puede variar si el bucle es recursivo o es iterativo, pero en este no cambia al seguir dependiendo de n.

Ejercicio 42
En este caso la cardinalidad de el conjunto va indicar el numero de elementos de el conjunto, por lo que la complejidad seria O(n^2), ya que por cada n que haya, se van a realizar dos operaciones, suma y resta al estar pidiendo el producto cartesiano.

Ejercicio 43
En este ejercicio hay un cambio con los anteriores, ya que se realizan dos bucles, donde uno esta encapsulado dentro del otro. Por lo tanto su complejidad temporal seria O(n*m), esta complejidad se usa al usar matrices ya que va a depender de las filas y columnas de la matriz.

Ejercicio 44
En este ejercicio se presenta una busqueda binaria dependera de la la cantidad de true o false que suelte el programa y el numero. Si tenemos un numero 5 y queremos buscarlo dentro de este array: [1,2,3,4,5], tendriamos que realizar 5 intrucciones. En cambio, si buscamos el 1 solo habria que realizar una instruccion. Esta complejidad temporal se escribe como O(log n).Pero esto solo funciona para arrays ordenados, por lo cual podemos decir esto:

Peor caso: O(n)
Mejor caso: O(1)
Caso promedio: O(n) o O(Log n)

Ejercicio 45
La complejidad de el anterior codigo de forma recursiva de este metodo sucede lo explicado en el anterior. El peor caso es 
O(n), depende de la cantidad de las llamadas recursivas.

Ejercicio 46
La complejidad de fibonacci recursivo seria O(n^2), debido a que por n llamadas habra otras n llamadas.

Ejercicio 47
Los resultados no dejan ver que mientras mayor se el n que se le de al metodo, mayor sera duracion de ejecucion del codigo, esto debeniendose a que el metodo tiene una complejidad de O(n). En este caso se usan potencias de 10, por lo que por cada sero que le aumentemos a n, se tentuplicara el tiempo de ejecucion

Ejercicio 48
En este caso podemos ver que es una complejidad temporal de O(n^2), debido a que se tiene que ejecutar dos veces n que seria i, siendo ejecutado primero una vez y de ahi volviendose a ejecutar otra vez.El problema es que al ser la complejidad asi los tiempos no dan por que se tendrian que multiplicar por 100 y no daria esos tiempos

Ejercicio 49
La verdad que este no lo entendi pero de lo que busque es la definicion temporal de la expresion big o.

Paloma so te soy sincero a partir de aca no entiendo nada, me parece que esta dificil de entender porque ya se escapa de mi conocimiento. El 50 y 51 no los hice por lo mismo.

Ejercicio 50

Ejercicio 51

Ejercicio 52
La complejidad temporal de este codigo es O((log n)^2)

Ejercicio 53
En este caso si puede variar la complejidad, como he explicado antes en el peor caso se supone que es O(n), pero cuando tenemos una lista ordenada se puede usar una busqueda binaria y su complejidad seria O(log n).

Ejercicio 54
1.20ns
2.1000ns
3.2000ns
4.1000000ns
5.10^7
6.10000ns

1.50ns
2.1ms
3.5ms
4.100s
5.10^31
6.10ms

1.5ms
2.100s
3.500s
4.10000000s
5.10^37s
6.1000s

Ejercicio 55
El problema por el cual no se puede dictaminar una partida perfecta a traves de la programacion es debido a la gran cantidad de combinaciones posibles en una partida de ajedrez, siendo incluso mayores a la cantidad de los electrones del universo. Por lo que seria practicamente imposible hoy en dia poder procesar esa cantidad de datos para generar una partida perfecta.